<!DOCTYPE html>
<html lang="en"> 
<head> 
 <meta charset="UTF-8"> 
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> 
 <title>The COLORSAMIFICATOR - V119 Engine Fixed</title> 
 <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script> 
 <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script> 
 <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> 
 <script src="https://cdn.tailwindcss.com"></script> 
 <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script> 
 
 <!-- FIREBASE COMPAT (Universal Support) -->
 <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
 <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
 <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

 <style> 
 body { height: 100vh; height: 100dvh; overscroll-behavior: none; }
 ::-webkit-scrollbar { width: 6px; height: 6px; } 
 ::-webkit-scrollbar-track { background: transparent; } 
 ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; } 
 ::-webkit-scrollbar-thumb:hover { background: #94a3b8; } 
 .scroll-hide::-webkit-scrollbar { display: none; }
 .scroll-hide { -ms-overflow-style: none; scrollbar-width: none; }
 </style> 
</head> 
<body class="bg-slate-200 w-screen overflow-hidden p-2 md:p-4 flex items-center justify-center font-sans"> 
 <div id="root" class="w-full h-full"></div> 
 <script type="text/babel"> 
 const { useState, useMemo, useEffect, useRef, useCallback } = React; 

 const saveToLocal = (key, data) => localStorage.setItem(`colorsam_v119_${key}`, JSON.stringify(data));
 const getFromLocal = (key, fallback) => {
    try { 
        const stored = localStorage.getItem(`colorsam_v119_${key}`);
        return stored ? JSON.parse(stored) : fallback; 
    } catch(e) { return fallback; }
 };

 // --- W3C REFERENCE MATH ENGINE (CSS COLOR 4) ---
 const lch2lab = (l, c, h) => {
    const hRad = (h * Math.PI) / 180;
    return [l, c * Math.cos(hRad), c * Math.sin(hRad)];
 };

 const lab2xyz = (l, a, b) => {
    const y = (l + 16) / 116;
    const x = a / 500 + y;
    const z = y - b / 200;
    
    // Fixed: The precise CSS Color 4 inverse transfer function
    const fInv = (n) => n > 0.20689655172413793 ? Math.pow(n, 3) : (116 * n - 16) / 903.2962962962963;
    
    const D50 = [0.96422, 1.00000, 0.82521]; 
    return [D50[0] * fInv(x), D50[1] * fInv(y), D50[2] * fInv(z)];
 };

 const xyz2lin_srgb = (X, Y, Z) => {
    // Exact D50-adapted sRGB matrix
    const r =  3.1338561 * X - 1.6168667 * Y - 0.4906146 * Z;
    const g = -0.9787684 * X + 1.9161415 * Y + 0.0334540 * Z;
    const b =  0.0719453 * X - 0.2289914 * Y + 1.4052427 * Z;
    return [r, g, b];
 };

 const lin2srgb = (lin) => {
    const gamma = (v) => {
        // Safe gamma curve handling for negative out-of-gamut values
        let absV = Math.abs(v);
        let res = absV <= 0.0031308 ? 12.92 * absV : 1.055 * Math.pow(absV, 1/2.4) - 0.055;
        return v < 0 ? -res : res;
    };
    return [gamma(lin[0]), gamma(lin[1]), gamma(lin[2])];
 };

 const xyz2lin_p3 = (X, Y, Z) => {
    const r =  2.4039833 * X - 0.9898394 * Y - 0.3976295 * Z;
    const g = -0.8421528 * X + 1.7988085 * Y + 0.0163351 * Z;
    const b =  0.0482087 * X - 0.1093952 * Y + 1.6134379 * Z;
    return [r, g, b];
 };

 const inGamut = ([r, g, b]) => {
    const e = 0.001; // Standard tolerance
    return r >= -e && r <= 1+e && g >= -e && g <= 1+e && b >= -e && b <= 1+e;
 };

 const realLchToRgb = (l, c, h) => {
    // Explicit anchor locks
    if (l >= 100) return { r: 255, g: 255, b: 255, outOfGamut: false };
    if (l <= 0) return { r: 0, g: 0, b: 0, outOfGamut: false };

    const [L, a, b] = lch2lab(l, c, h);
    const [X, Y, Z] = lab2xyz(L, a, b);
    let linRGB = xyz2lin_srgb(X, Y, Z);

    let outOfGamut = !inGamut(linRGB);
    
    if (outOfGamut) {
        let minC = 0; let maxC = c; let bestC = 0;
        for (let i = 0; i < 20; i++) {
            const midC = (minC + maxC) / 2;
            const [tL, ta, tb] = lch2lab(l, midC, h);
            const [tX, tY, tZ] = lab2xyz(tL, ta, tb);
            const tRGB = xyz2lin_srgb(tX, tY, tZ);
            if (inGamut(tRGB)) { bestC = midC; minC = midC; } else { maxC = midC; }
        }
        const [mL, ma, mb] = lch2lab(l, bestC, h);
        const [mX, mY, mZ] = lab2xyz(mL, ma, mb);
        linRGB = xyz2lin_srgb(mX, mY, mZ);
    }

    const [rr, gg, bb] = lin2srgb(linRGB);
    const clamp = (v) => Math.round(Math.max(0, Math.min(1, v)) * 255);

    return { r: clamp(rr), g: clamp(gg), b: clamp(bb), outOfGamut };
 };

 const checkGamutStatus = (l, c, h) => {
    if (l >= 100 || l <= 0) return { isSRGB: true, isP3: true }; 
    const [L, a, b] = lch2lab(l, c, h);
    const [X, Y, Z] = lab2xyz(L, a, b);
    const linSRGB = xyz2lin_srgb(X, Y, Z);
    const linP3 = xyz2lin_p3(X, Y, Z);
    return { isSRGB: inGamut(linSRGB), isP3: inGamut(linP3) };
 };
 
 const checkGamut = checkGamutStatus; // Alias

 // --- CONSTANTS ---
 const generateLightRanges = () => {
    const ranges = [{ label: "A", min: 0, max: 0, mid: 0 }]; 
    for (let i = 0; i < 19; i++) {
        const start = 1 + (i * 5);
        ranges.push({ label: String.fromCharCode(66 + i), min: start, max: start + 4, mid: start + 2 });
    }
    ranges.push({ label: "U", min: 96, max: 99, mid: 97.5 });
    ranges.push({ label: "V", min: 100, max: 100, mid: 100 });
    return ranges;
 };

 const generateChromaRanges = () => {
    const ranges = [{ label: "A", min: 0, max: 0, mid: 0 }];
    ranges.push({ label: "B", min: 1, max: 9, mid: 5 });
    for (let i = 0; i < 7; i++) {
        const start = 10 + (i * 10);
        ranges.push({ label: String.fromCharCode(67 + i), min: start, max: start + 9, mid: start + 4.5 });
    }
    ranges.push({ label: "J", min: 80, max: 100, mid: 90 });
    return ranges;
 };

 const NEW_LIGHT_RANGES = generateLightRanges();
 const NEW_CHROMA_RANGES = generateChromaRanges();
 const NEW_HUE_VALUES = Array.from({length: 120}, (_, i) => i * 3);
 const DEFAULT_ANCHORS = [{ label: "Dark", l: 25, c: 30 }, { label: "Light", l: 75, c: 30 }];
 
 // --- MIGRATION DATA ---
 const OLD_ADJECTIVES = [["", "", "", "", "", "", "", "", "", "", "", ""], ["Void", "Null", "Pitch", "Dark", "Murky", "Stygian", "Hollow", "Deepest", "Bottom", "Under", "Nether", "Crypt"], ["Inky", "Raven", "Sable", "Shaded", "Opaque", "Vast", "Core", "Total", "Ultra", "Hyper", "Blind", "Grim"], ["Steely", "Dense", "Deep", "Hard", "Rigid", "Stern", "Massive", "Major", "Main", "Mega", "Iron", "Lead"], ["Dim", "Dusk", "Matte", "Solid", "Stout", "Strong", "Mighty", "Potent", "Power", "Force", "Tough", "Hardy"], ["Muted", "Plain", "Flat", "Dry", "Base", "Raw", "Firm", "Heavy", "Grand", "Epic", "Regal", "Noble"], ["Dusty", "Ashen", "Tame", "Smooth", "Pure", "Prime", "Rich", "Lush", "Ripe", "True", "Bold", "Wild"], ["Foggy", "Hazy", "Mild", "Crisp", "Light", "Keen", "Sharp", "Electric", "Vibrant", "Neon", "Flux", "Pulse"], ["Pale", "Fair", "Clean", "Fresh", "Clear", "Bright", "Sunny", "Glowing", "Shining", "Spark", "Luster", "Gloss"], ["Faint", "Thin", "Fine", "Lite", "Soft", "Bleached", "Luminous", "Brilliant", "Beam", "Ray", "Gleam", "Silky"], ["Stark", "Sheer", "Wispy", "Snowy", "Chalky", "Blinding", "Radiant", "Beaming", "Flash", "Flare", "Solar", "White"], ["", "", "", "", "", "", "", "", "", "", "", ""]];
 const OLD_NOUNS = ["Mallow,Rose,Raisin,Garnet,Petal,Cerise", "Mauve,Pink,Prune,Rubellite,Blossom,Fuchsia", "Heather,Magenta,Fig,Tourmaline,Orchid,Neon", "Lilac,Berry,Mulberry,Spinel,Bud,Laser", "Dust,Ruby,Wine,Rhodolite,Rose,Hot", "Ash,Crimson,Merlot,Zircon,Pink,Pop", "Stone,Scarlet,Currant,Beryl,Salmon,Flash", "Clay,Vermilion,Brick,Jasper,Coral,Beam", "Sand,Red,Rust,Agate,Peach,Ray", "Silt,Cherry,Mahogany,Carnelian,Melon,Glow", "Pottery,Poppy,Carob,Agate,Almond,Mango", "Nutmeg,Nasturtium,Mocha,Sardonyx,Buff,Sorbet", "Terracotta,Paprika,Cocoa,Carnelian,Ecru,Sherbet", "Curry,Lantern,Bean,Magma,Dough,Squash", "Sahara,Kumquat,Peat,Volcano,Fawn,Yam", "Arid,Titian,Soil,Obsidian,Beige,Mandarin", "Bronze,Carrot,Grit,Root,Sand,Satsuma", "Copper,Zinnia,Leather,Cove,Dune,Calendula", "Brass,Tiger,Saddle,Bark,Wheat,Sunflower", "Pyrite,Ginger,Hide,Cavern,Grain,Daylily", "Mesa,Orange,Bison,Tortoise,Cream,Gold", "Bronze,Marigold,Clove,Topaz,Biscuit,Apricot", "Ochre,Squash,Nutmeg,Amber,Wheat,Maize", "Spice,Tangerine,Truffle,Citrine,Grain,Cream", "Cumin,Yam,Coffee,Tiger,Dough,Manila", "Camel,Clementine,Caraway,Pyrite,Ecru,Buff", "Fawn,Mango,Umber,Cognac,Oat,Blond", "Dijon,Saffron,Malt,Brandy,Sol,Vanilla", "Mustard,Turmeric,Stout,Whiskey,Beige,Banana", "Curry,Gold,Hemp,Bourbon,Sand,Lager", "Brass,Sunflower,Burlap,Cider,Straw,Lemon", "Straw,Dandelion,Thatch,Ale,Parchment,Chiffon", "Khaki,Canary,Rope,Mead,Ivory,Butter", "Gamba,Solar,Cork,Syrup,Bone,Custard", "Rattan,Sulfur,Twine,Toffee,Linen,Daffodil", "Stalk,Mimosa,Reed,Caramel,Lace,Pineapple", "Weave,Buttercup,Cane,Butterscotch,Silk,Daisy", "Chino,Honey,Cask,Molasses,Cloud,Corn", "Husk,Medallion,Bark,Treacle,Pearl,Popcorn", "Suede,Bumblebee,Silt,Root,Alabaster,Cheese", "Dust,Jonquil,Soil,Fossil,Cotton,Primrose", "Raffia,Dandelion,Rattan,Resin,Parchment,Chiffon", "Agave,Zest,Wicker,Sap,Ivory,Butter", "Flaxen,Citron,Bamboo,Comb,Tusk,Custard", "Straw,Bumblebee,Reed,Hive,Linen,Daffodil", "Ecru,Mace,Cane,Pollen,Lace,Pineapple", "Sand,Canary,Thatch,Wax,Silk,Daisy", "Oat,Mimosa,Rope,Ingot,Cloud,Corn", "Wheat,Flax,Cork,Nugget,Pearl,Popcorn", "Khaki,Gorse,Fiber,Bullion,Alabaster,Cheese", "Gamba,Corn,Twine,Gilt,Cotton,Primrose", "Husk,Butter,Bale,Or,Chalk,Vanilla", "Suede,Lemon,Hay,Medal,Milk,Meringue", "Dust,Solar,Hessian,Trophy,Foam,Wafer", "Cream,Jonquil,Jute,Crown,Mist,Buttermilk", "Custard,Titan,Cord,Ocre,Haze,Shortbread", "Blond,Medallion,Bran,Sulphur,Puff,Pastry", "Camel,Cadmium,Grain,Pyrite,Down,Cookie", "Fawn,Genista,Seed,Brass,Feather,Cake", "Dijon,Aureolin,Husk,Bronze,Vapor,Frosting", "Mustard,Yellow,Loam,Mineral,Snow,Icing", "Pickle,Acid,Olive,Sulphur,Rind,Tart", "Caper,Quince,Pesto,Pyrite,Pulp,Dill", "Lichen,Reed,Algae,Marcasite,Shoot,Endive", "Moss,Absinthe,Kelp,Zircon,Bud,Fennel", "Sage,Peridot,Nori,Olivine,Stem,Anise", "Brine,Linden,Hemp,Sphene,Aloe,Tea", "Fern,Verdet,Jute,Serpent,Palm,Melon", "Basil,Chrysolite,Sisal,Diopside,Silk,Apple", "Laurel,Pear,Spinach,Idocrase,Shea,Mint", "Myrtle,Chartreuse,Kale,Tourmaline,Foam,Glow", "Cactus,Pomelo,Collard,Dragon,Mist,Volt", "Agave,Wasabi,Chard,Viper,Dew,Ray", "Reseda,Celadon,Nettle,Lizard,Spray,Laser", "Willow,Pistachio,Sorrel,Iguana,Balm,Neon", "Thyme,Avocado,Herbal,Mamba,Whisp,Limeade", "Oregano,Lemongrass,Verdant,Python,Breeze,Zest", "Savory,Verbena,Grove,Cobra,Puff,Sprite", "Marjoram,Beryl,Copse,Drake,Air,Fizz", "Lichen,Neon,Thicket,Wyvern,Vapor,Spark", "Taiga,Lime,Forest,Basilisk,Snow,Flux", "Basil,Bud,Thicket,Zircon,Dew,Mint", "Oregano,Sprout,Grove,Spinel,Aloe,Foam", "Sage,Kiwi,Copse,Garnet,Shea,Mist", "Thyme,Parrot,Brake,Tsavorite,Balm,Spray", "Bay,Mantis,Hedge,Uvarovite,Whisp,Fizz", "Laurel,Fern,Shrub,Verdite,Cloud,Ray", "Savory,Eden,Bush,Chrome,Vapor,Volt", "Nettle,Cactus,Bracken,Emerald,Air,Beam", "Hemp,Matcha,Brier,Beryl,Puff,Flash", "Tea,Foliage,Thorn,Jade,Mist,Neon", "Matcha,Iguana,Bramble,Malachite,Soft,Glow", "Pesto,Leaf,Undergrowth,Serpentine,Cotton,Pulse", "Sage,Olive,Thicket,Peridot,Aloe,Beam", "Laurel,Fern,Grove,Verdite,Mint,Ray", "Myrtle,Moss,Forest,Emerald,Foam,Glow", "Basil,Algae,Jungle,Jade,Dew,Volt", "Thyme,Kelp,Copse,Malachite,Mist,Neon", "Teal,Seaweed,Abyss,Beryl,Aqua,Cyan", "Cyan,Spruce,Deep,Turquoise,Sky,Electric", "Azure,Pine,Ocean,Sapphire,Ice,Bolt", "Cobalt,Denim,Midnight,Lapis,Frost,Laser", "Blue,Navy,Abyss,Indigo,Mist,Ray", "Indigo,Ink,Void,Violet,Lilac,Glow", "Violet,Grape,Night,Amethyst,Orchid,Neon", "Purple,Plum,Shadow,Magenta,Rose,Beam", "Magenta,Berry,Deep,Fuchsia,Pink,Flash", "Pink,Rose,Wine,Ruby,Blush,Glow", "Red,Brick,Blood,Garnet,Coral,Spark", "Orange,Rust,Clay,Amber,Peach,Ray", "Gold,Ochre,Earth,Topaz,Cream,Beam", "Yellow,Dijon,Sand,Citrine,Lemon,Flash", "Lime,Moss,Slime,Peridot,Mint,Glow"];

 const generateAdjectiveMatrix = () => {
    const matrix = [];
    for(let l=0; l<22; l++) {
        const row = [];
        for(let c=0; c<10; c++) {
            const oldL = Math.floor(l * (12/22));
            const oldC = Math.floor(c * (12/10));
            row.push(OLD_ADJECTIVES[Math.min(11, oldL)][Math.min(11, oldC)] || "");
        }
        matrix.push(row);
    }
    return matrix;
 };

 const generateNounData = () => {
    const nouns = [];
    for(let i=0; i<120; i++) {
        const deg = i * 3;
        let oldIdx = 0;
        if (deg <= 120) oldIdx = Math.round(deg / 2);
        else oldIdx = 60 + Math.round((deg - 120) / 6);
        oldIdx = Math.max(0, Math.min(OLD_NOUNS.length - 1, oldIdx));

        const oldRowParts = OLD_NOUNS[oldIdx].split(',');
        const darkNoun = oldRowParts[2] || oldRowParts[3] || oldRowParts[1] || "Hue";
        const lightNoun = oldRowParts[0] || oldRowParts[5] || oldRowParts[4] || "Hue";
        nouns.push(`${darkNoun},${lightNoun}`);
    }
    return nouns;
 };

 // --- COMPONENTS ---
 const Icon = ({ children, className, onClick }) => <svg onClick={onClick} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>; 
 const Grid = ({ className }) => <Icon className={className}><rect width="18" height="18" x="3" y="3" rx="2" /><path d="M3 9h18" /><path d="M3 15h18" /><path d="M9 3v18" /><path d="M15 3v18" /></Icon>; 
 const ChevronLeft = ({ className }) => <Icon className={className}><path d="m15 18-6-6 6-6" /></Icon>; 
 const ChevronRight = ({ className }) => <Icon className={className}><path d="m9 18 6-6-6-6" /></Icon>; 
 const Tag = ({ className }) => <Icon className={className}><path d="M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l5 5a2 2 0 0 0 2.828 0l7.172-7.172a2 2 0 0 0 0-2.828l-5-5Z" /><path d="M7 7h.01" /></Icon>; 
 const RefreshCw = ({ className, onClick }) => <Icon onClick={onClick} className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" /><path d="M8 16H3v5" /></Icon>; 
 const Download = ({ className, onClick }) => <Icon onClick={onClick} className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></Icon>; 
 const Upload = ({ className }) => <Icon className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" x2="12" y1="3" y2="15" /></Icon>; 
 const Palette = ({ className }) => <Icon className={className}><circle cx="13.5" cy="6.5" r=".5" fill="currentColor" /><circle cx="17.5" cy="10.5" r=".5" fill="currentColor" /><circle cx="8.5" cy="7.5" r=".5" fill="currentColor" /><circle cx="6.5" cy="12.5" r=".5" fill="currentColor" /><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.093 0-.84.672-1.531 1.514-1.531h2.418c4.281 0 7.793-3.351 7.793-7.609C24.496 4.672 18.902 2 12 2Z" /></Icon>; 
 const Hash = ({ className }) => <Icon className={className}><line x1="4" x2="20" y1="9" y2="9" /><line x1="4" x2="20" y1="15" y2="15" /><line x1="10" x2="8" y1="3" y2="21" /><line x1="16" x2="14" y1="3" y2="21" /></Icon>; 
 const Ruler = ({ className }) => <Icon className={className}><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z"/><path d="m14.5 12.5 2-2"/><path d="m11.5 9.5 2-2"/><path d="m8.5 6.5 2-2"/><path d="m17.5 15.5 2-2"/></Icon>;
 const Sparkles = ({ className, onClick }) => <Icon onClick={onClick} className={className}><path d="m12 3 1.912 5.813a2 2 0 0 0 1.275 1.275L21 12l-5.813 1.912a2 2 0 0 0-1.275 1.275L12 21l-1.912-5.813a2 2 0 0 0-1.275-1.275L3 12l5.813-1.912a2 2 0 0 0 1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M3 5h4"/><path d="M21 17v4"/><path d="M19 19h4"/></Icon>;
 const Layers = ({ className }) => <Icon className={className}><polygon points="12 2 2 7 12 12 22 7 12 2" /><polyline points="2 17 12 22 22 17" /><polyline points="2 12 12 17 22 12" /></Icon>;
 const Plus = ({ className }) => <Icon className={className}><line x1="12" y1="5" x2="12" y2="19" /><line x1="5" y1="12" x2="19" y2="12" /></Icon>;
 const X = ({ className }) => <Icon className={className}><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></Icon>;
 const Monitor = ({ className }) => <Icon className={className}><rect width="20" height="14" x="2" y="3" rx="2" /><line x1="8" x2="16" y1="21" y2="21" /><line x1="12" x2="12" y1="17" y2="21" /></Icon>;
 const AlertTriangle = ({ className }) => <Icon className={className}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" /><line x1="12" x2="12" y1="9" y2="13" /><line x1="12" x2="12.01" y1="17" y2="17" /></Icon>;
 const Cloud = ({ className }) => <Icon className={className}><path d="M17.5 19c0-1.7-1.3-3-3-3h-1.1c-.2-2.3-2.1-4-4.4-4-2.5 0-4.5 1.8-4.9 4.2C1.9 16.5 0 18.5 0 21s2 4.5 4.5 4.5h13c2.5 0 4.5-2 4.5-4.5S20 16.5 17.5 19zM13 13l-3-3-3 3M10 10v9" /></Icon>; 
 const CloudOff = ({ className }) => <Icon className={className}><path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 7h1.18a3 3 0 0 0-.44 10.3M2 2l20 20" /></Icon>;

 const SnapControl = ({ label, value, setter, max, displayVal, gradient, isInverted, isActive }) => { 
    const [localText, setLocalText] = useState(displayVal); 
    useEffect(() => { setLocalText(displayVal); }, [displayVal]); 
    const commitChange = () => { 
        let val = parseInt(localText); 
        if (isNaN(val)) { setLocalText(displayVal); return; } 
        if (label === "Hue") { if (val < 0) val = 0; if (val > 360) val = 360; setter(val); } 
        else { if (val < 0) val = 0; if (val > max) val = max; setter(val); } 
    }; 
    return ( 
    <div className={`flex flex-col gap-2 mb-4 p-2 rounded-xl transition-all duration-300 ${isActive ? 'bg-blue-50 ring-2 ring-blue-500 shadow-sm' : 'hover:bg-slate-50'}`}> 
    <div className="flex justify-between items-center text-xs font-bold uppercase text-slate-500"> 
        <span className={isActive ? 'text-blue-700' : ''}>{label}</span> 
        <input type="text" value={localText} onChange={(e) => setLocalText(e.target.value)} onBlur={commitChange} onKeyDown={(e) => e.key === 'Enter' && commitChange()} className={`font-mono text-right w-12 bg-transparent border-b ${isActive ? 'border-blue-300 text-blue-700' : 'border-slate-300'} focus:border-blue-500 focus:outline-none`} /> 
    </div> 
    <div className="flex items-center gap-3"> 
        <button onClick={() => setter(isInverted ? Math.min(max, value + 1) : Math.max(0, value - 1))} className={`w-8 h-8 flex items-center justify-center rounded-full border shadow-sm transition-colors ${isActive ? 'bg-blue-100 border-blue-200 text-blue-700' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}><ChevronLeft className="w-4 h-4" /></button> 
        <div className="relative flex-1 h-6"> 
        <input type="range" min="0" max={max} value={isInverted ? max - value : value} onChange={(e) => { const val = parseInt(e.target.value); setter(isInverted ? max - val : val); }} className="w-full h-full absolute top-0 left-0 z-20 opacity-0 cursor-pointer appearance-none bg-transparent" /> 
        <div className="w-full h-3 rounded-full absolute top-1.5 z-0 border border-black/5" style={{ background: gradient, backgroundSize: '100% 100%' }} /> 
        <div className="h-6 w-6 bg-white border border-slate-300 rounded-full shadow-md absolute top-0 z-10 pointer-events-none transition-transform flex items-center justify-center text-[10px]" style={{ left: `calc(${(((isInverted ? max - value : value) / max) * 100)}% - 12px)` }} /> 
        </div> 
        <button onClick={() => setter(isInverted ? Math.max(0, value - 1) : Math.min(max, value + 1))} className={`w-8 h-8 flex items-center justify-center rounded-full border shadow-sm transition-colors ${isActive ? 'bg-blue-100 border-blue-200 text-blue-700' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}><ChevronRight className="w-4 h-4" /></button> 
    </div> 
    </div> 
    ); 
 }; 

 const MatrixTable = ({ yData, xData, yLabel, xLabel, renderCell, activeIds, interactionSource }) => { 
    const containerRef = useRef(null);
    const activeRowIdx = activeIds.r;
    const activeColIdx = activeIds.c;

    useEffect(() => {
        if (interactionSource && interactionSource.current === 'click') {
            interactionSource.current = null;
            return;
        }
        if (containerRef.current) {
            const activeEl = containerRef.current.querySelector('[data-active="true"]');
            if (activeEl) {
                activeEl.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'nearest' });
            }
        }
    }, [activeRowIdx, activeColIdx, interactionSource]);

    return ( 
    <div ref={containerRef} className="h-full w-full overflow-auto rounded-xl border border-slate-200 bg-white shadow-sm flex flex-col relative"> 
        <table className="min-w-max text-[10px] text-center border-separate border-spacing-1 table-fixed relative z-10"> 
            <thead> 
                <tr> 
                    <th className="p-2 text-slate-300 font-mono text-left bg-white sticky top-0 z-40 w-20 border-b border-slate-100"><span>{yLabel}\{xLabel}</span></th> 
                    {xData.map((col) => ( 
                    <th key={col.index} className={`p-2 font-bold border-b border-slate-100 bg-white sticky top-0 z-40 ${col.isActive ? 'text-blue-600 bg-blue-50 ring-inset ring-2 ring-blue-500/20 rounded-t' : 'text-slate-500'}`}> 
                        <div className="flex flex-col items-center"><span className="text-xs">{col.label}</span>{col.data && (<span className="text-[8px] font-normal opacity-50 font-mono">{col.data.min === col.data.max ? col.data.min : `${col.data.min}-${col.data.max}`}</span>)}</div> 
                    </th> 
                    ))} 
                </tr> 
            </thead> 
            <tbody> 
                {yData.map((row) => (
                    <tr key={row.index}>
                        <td className={`p-2 font-bold border-r border-slate-100 text-left bg-white sticky left-0 z-30 ${row.isActive ? 'text-blue-600 bg-blue-50 ring-inset ring-2 ring-blue-500/20 rounded-l' : 'text-slate-500'}`}>
                            <div className="flex flex-col"><span className="text-xs">{row.label}</span>{row.data && (<span className="text-[8px] font-normal opacity-50 font-mono">{row.data.min === row.data.max ? row.data.min : `${row.data.min}-${row.data.max}`}</span>)}</div>
                        </td>
                        {xData.map((col) => renderCell(row.index, col.index))}
                    </tr>
                ))} 
            </tbody> 
        </table> 
    </div> 
    ) 
 }; 

 const HarmonySwatch = ({ offset, label, currentH, currentL, currentC, setH, displayGamut }) => { 
    let harmH = (currentH + offset) % 360; 
    if (harmH < 0) harmH += 360; 
    
    let harmL = currentL; 
    let harmC = currentC; 
    if (harmC < 5) harmC = 60; 
    if (harmL < 10 || harmL > 90) harmL = 50; 
    
    const gamutStatus = checkGamut(harmL, harmC, harmH);
    const rgb = realLchToRgb(harmL, harmC, harmH);
    const swatchColor = `rgb(${rgb.r},${rgb.g},${rgb.b})`; 
    const hatch = { backgroundImage: 'repeating-linear-gradient(45deg, #cbd5e1 0px, #cbd5e1 4px, transparent 4px, transparent 8px)', backgroundColor: 'transparent' };
    
    const isOutOfGamut = displayGamut === 'p3' ? !gamutStatus.isP3 : !gamutStatus.isSRGB;

    return ( 
    <div onClick={() => setH(harmH)} className="flex flex-col items-center gap-1 cursor-pointer group"> 
        <div className="w-8 h-8 rounded-full shadow-sm border border-black/10 group-hover:scale-110 transition-transform relative overflow-hidden" 
            style={isOutOfGamut ? hatch : { backgroundColor: swatchColor }}> 
        </div> 
        <span className="text-[8px] font-bold text-slate-400 uppercase">{label}</span> 
    </div> 
    ) 
 }; 

 const ColorSAMIfier = () => { 
    // --- STATE ---
    const [h, setH] = useState(getFromLocal('h', 40)); 
    const [c, setC] = useState(getFromLocal('c', 50)); 
    const [l, setL] = useState(getFromLocal('l', 52)); 
    const [activeView, setActiveView] = useState("hue_pivot"); 
    const [isFlipped, setIsFlipped] = useState(false); 
    const interactionSource = useRef(null); 
    const [displayGamut, setDisplayGamut] = useState("srgb");
    const [nameWarning, setNameWarning] = useState(null);

    const [lightRanges, setLightRanges] = useState(getFromLocal('lightRanges', NEW_LIGHT_RANGES));
    const [chromaRanges, setChromaRanges] = useState(getFromLocal('chromaRanges', NEW_CHROMA_RANGES));
    const [anchors, setAnchors] = useState(getFromLocal('anchors', DEFAULT_ANCHORS));
    const [hueValues, setHueValues] = useState(getFromLocal('hueValues', NEW_HUE_VALUES));
    
    const [adjectiveMatrix, setAdjectiveMatrix] = useState(() => {
        const local = getFromLocal('adjectiveMatrix', null);
        return (local && local.length === 22) ? local : generateAdjectiveMatrix();
    });
    
    const [nounData, setNounData] = useState(() => {
        const local = getFromLocal('nounData', null);
        return (local && local.length === 120) ? local : generateNounData();
    });
    
    const [palette, setPalette] = useState(getFromLocal('userPalette', []));
    
    // Cloud State
    const [isCloudEnabled, setIsCloudEnabled] = useState(false);
    const [isSynced, setIsSynced] = useState(false);
    const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
    const dbRef = useRef(null);
    const docRef = useRef(null);
    
    const [tempName, setTempName] = useState(null);

    const parsedNouns = useMemo(() => nounData.map(row => row.split(',')), [nounData]);

    // Init Firebase (Compat)
    useEffect(() => {
        const init = async () => {
             if (typeof window.firebase === 'undefined') {
                 console.warn("Firebase scripts not loaded. Offline mode.");
                 return;
             }
             if (typeof __firebase_config === 'undefined' || !__firebase_config) {
                 console.warn("Firebase config missing. Offline mode.");
                 return;
             }
             try {
                const firebaseConfig = JSON.parse(__firebase_config);
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                }
                const auth = firebase.auth();
                const db = firebase.firestore();
                dbRef.current = db;

                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                
                // Auth
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await auth.signInWithCustomToken(__initial_auth_token);
                } else {
                    await auth.signInAnonymously();
                }

                const d = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('colorsami_v1').doc('main');
                docRef.current = d;
                
                d.onSnapshot((snapshot) => {
                    if (snapshot.exists) {
                        const data = snapshot.data();
                        if (data.lightRanges) setLightRanges(data.lightRanges);
                        if (data.chromaRanges) setChromaRanges(data.chromaRanges);
                        if (data.hueValues) setHueValues(data.hueValues);
                        if (data.adjectiveMatrix) setAdjectiveMatrix(data.adjectiveMatrix);
                        if (data.nounData) setNounData(data.nounData);
                        
                        setIsSynced(true);
                        setHasUnsavedChanges(false);
                    }
                }, (error) => {
                    console.error("Sync error:", error);
                    setIsSynced(false);
                });

                setIsCloudEnabled(true);
             } catch (e) {
                 console.error("Firebase init failed:", e);
             }
        };
        init();
    }, []);

    useEffect(() => {
        if (window.matchMedia && window.matchMedia("(color-gamut: p3)").matches) {
            setDisplayGamut("p3");
        } else {
            setDisplayGamut("srgb");
        }

        saveToLocal('h', h); saveToLocal('c', c); saveToLocal('l', l);
        saveToLocal('lightRanges', lightRanges); saveToLocal('chromaRanges', chromaRanges);
        saveToLocal('anchors', anchors); saveToLocal('hueValues', hueValues);
        saveToLocal('adjectiveMatrix', adjectiveMatrix);
        saveToLocal('nounData', nounData);
        saveToLocal('userPalette', palette);
        
        if (isCloudEnabled) setHasUnsavedChanges(true);

    }, [h, c, l, adjectiveMatrix, nounData, lightRanges, chromaRanges, anchors, hueValues, palette, isCloudEnabled]);
    
    useEffect(() => {
        setTempName(null);
    }, [l, c, h]);

    // Cloud Save Function
    const handleCloudSave = async () => {
        if (!docRef.current) return;
        try {
            await docRef.current.set({
                lightRanges, chromaRanges, hueValues, adjectiveMatrix, nounData, lastUpdated: new Date().toISOString()
            });
            setHasUnsavedChanges(false);
        } catch (e) {
            console.error("Save failed:", e);
            alert("Failed to save to cloud.");
        }
    };

    const updateAdjective = (r, c, val) => {
        setAdjectiveMatrix(prev => {
            const next = [...prev];
            next[r] = [...next[r]];
            next[r][c] = val;
            return next;
        });
    };

    const updateNoun = (r, c, val) => {
        setNounData(prev => {
            const next = [...prev];
            const rowStr = next[r] || "";
            const parts = rowStr.split(',');
            while (parts.length < 2) parts.push("");
            parts[c] = val;
            next[r] = parts.join(',');
            return next;
        });
    };

    const getIndexFromHue = (hue) => { 
        let closestIdx = 0;
        let minDiff = 360;
        hueValues.forEach((hVal, idx) => {
            let diff = Math.abs(hVal - hue);
            if(diff > 180) diff = 360 - diff; 
            if(diff < minDiff) {
                minDiff = diff;
                closestIdx = idx;
            }
        });
        return closestIdx;
    }; 
    
    const hIdx = getIndexFromHue(h);
    const lIdx = lightRanges.findIndex(rg => l >= rg.min && l <= rg.max); 
    const cIdx = chromaRanges.findIndex(rg => c >= rg.min && c <= rg.max); 

    const getNounColumnIndex = (lIdx) => { 
        return lIdx < 11 ? 0 : 1;
    }; 

    const currentMapping = useMemo(() => { 
        const rowLIdx = lightRanges.findIndex(rg => l >= rg.min && l <= rg.max);
        const rowCIdx = chromaRanges.findIndex(rg => c >= rg.min && c <= rg.max);
        
        if (rowLIdx === -1 || rowCIdx === -1) return { baseNoun: "Unknown", adj: "Unknown", code: "???", strIdx: -1, hueRow: hIdx };

        if (rowLIdx === 0) return { baseNoun: "Nero", adj: "", code: `AA000`, strIdx:-1, hueRow:-1 }; 
        if (rowLIdx === 21) return { baseNoun: "Blanc", adj: "", code: `VA000`, strIdx:-1, hueRow:-1 }; 
        if (rowCIdx === 0) return { baseNoun: "Cinza", adj: adjectiveMatrix[rowLIdx]?.[0] || "", code: `${lightRanges[rowLIdx]?.label || 'A'}A000`, strIdx:-1, hueRow:-1 }; 
        
        const sIdx = getNounColumnIndex(rowLIdx);
        const bNoun = parsedNouns[hIdx]?.[sIdx] || "Hue"; 
        let adj = adjectiveMatrix[rowLIdx]?.[rowCIdx] || ""; 
        if (bNoun && adj && bNoun.toLowerCase() === adj.toLowerCase()) adj = ""; 
        return { baseNoun: bNoun, adj, code: `${lightRanges[rowLIdx]?.label || '?'}${chromaRanges[rowCIdx]?.label || '?'}${h.toString().padStart(3,'0')}`, strIdx: sIdx, hueRow: hIdx }; 
    }, [l, c, h, adjectiveMatrix, parsedNouns, hIdx, lightRanges, chromaRanges]);

    const fullDisplayName = currentMapping.adj ? `${currentMapping.adj} ${currentMapping.baseNoun}` : currentMapping.baseNoun; 

    // --- DUPLICATE HANDLER ---
    const handleNameChange = (val) => {
        const rL = lightRanges.findIndex(rg => l >= rg.min && l <= rg.max);
        const rC = chromaRanges.findIndex(rg => c >= rg.min && c <= rg.max);
        
        if (rL === 0 || rL === 21) return; 

        const parts = val.trim().split(/\s+/);
        let newNoun = "";
        let newAdj = "";
        
        if (parts.length === 1) { newNoun = parts[0]; } else { newNoun = parts.pop(); newAdj = parts.join(" "); }
        
        const checkNoun = newNoun.trim();
        const checkAdj = newAdj.trim();

        let warning = null;

        if (rC === 0) {
            if (rL !== -1) updateAdjective(rL, 0, val.replace("Cinza", "").trim());
        } else {
             const sIdx = getNounColumnIndex(rL);
             const hRow = hIdx;
             
             if (hRow !== -1) updateNoun(hRow, sIdx, checkNoun);
             if (rL !== -1 && rC !== -1) updateAdjective(rL, rC, checkAdj);
             
             if (checkNoun && checkNoun.toLowerCase() !== "hue") {
                 for(let h=0; h<parsedNouns.length; h++) {
                     for(let s=0; s<2; s++) {
                         if (h === hRow && s === sIdx) continue;
                         const existing = parsedNouns[h][s];
                         if (existing && existing.toLowerCase() === checkNoun.toLowerCase()) {
                             warning = `Duplicate Noun '${checkNoun}' found at ${hueValues[h]}° / ${s === 0 ? 'Dark' : 'Light'}`;
                         }
                     }
                 }
             }
             if (checkAdj) {
                 for(let r=0; r<adjectiveMatrix.length; r++) {
                     for(let cIter=0; cIter<adjectiveMatrix[r].length; cIter++) {
                         if (r === rL && cIter === rC) continue;
                         const existing = adjectiveMatrix[r][cIter];
                         if (existing && existing.toLowerCase() === checkAdj.toLowerCase()) {
                             warning = `Duplicate Adjective '${checkAdj}' found at L:${lightRanges[r].label} C:${chromaRanges[cIter].label}`;
                         }
                     }
                 }
             }
        }
        setNameWarning(warning);
    };

    // CANONICAL REFERENCE
    const safeLIdx = lightRanges.findIndex(rg => l >= rg.min && l <= rg.max);
    const safeCIdx = chromaRanges.findIndex(rg => c >= rg.min && c <= rg.max);
    
    const canonicalL = lightRanges[safeLIdx]?.mid ?? 50;
    const canonicalC = chromaRanges[safeCIdx]?.mid ?? 0;
    const canonicalH = hueValues[hIdx] ?? 0;
    const canonRgb = realLchToRgb(canonicalL, canonicalC, canonicalH);
    const canonHex = `#${canonRgb.r.toString(16).padStart(2,'0')}${canonRgb.g.toString(16).padStart(2,'0')}${canonRgb.b.toString(16).padStart(2,'0')}`.toUpperCase();
    const canonGamut = checkGamut(canonicalL, canonicalC, canonicalH);
    const deltaE = Math.sqrt(Math.pow(canonicalL - l, 2) + Math.pow(canonicalC - c, 2)).toFixed(1); 

    // --- EXPLORER RENDER LOGIC ---
    const getExplorerParams = useCallback((view, flipped, rI, cI) => {
        let localLIdx = safeLIdx, localCIdx = safeCIdx, localHIdx = hIdx;
        if (localLIdx === -1) localLIdx = 0; if (localCIdx === -1) localCIdx = 0;

        if (view === "hue_pivot") {
            localLIdx = flipped ? cI : rI;
            localCIdx = flipped ? rI : cI;
        } else if (view === "chroma_pivot") {
            localHIdx = flipped ? cI : rI;
            localLIdx = flipped ? rI : cI;
            localCIdx = safeCIdx; 
        } else if (view === "light_pivot") {
            localHIdx = flipped ? cI : rI;
            localCIdx = flipped ? rI : cI;
            localLIdx = safeLIdx;
        }
        
        const safeL = lightRanges[localLIdx] || lightRanges[0];
        const safeC = chromaRanges[localCIdx] || chromaRanges[0];
        const safeH = hueValues[localHIdx] ?? 0;
        
        return { lVal: safeL.mid, cVal: safeC.mid, hVal: safeH, lIdx: localLIdx, cIdx: localCIdx, hIdx: localHIdx };
    }, [safeLIdx, safeCIdx, hIdx, lightRanges, chromaRanges, hueValues]);

    const handleExport = () => { 
        const wb = XLSX.utils.book_new(); 
        
        const rangesData = [
            ["Type", "Label", "Min", "Max", "Mid"],
            ...lightRanges.map(r => ["Light", r.label, r.min, r.max, r.mid]),
            ...chromaRanges.map(r => ["Chroma", r.label, r.min, r.max, r.mid])
        ];
        const rangeWS = XLSX.utils.aoa_to_sheet(rangesData);
        XLSX.utils.book_append_sheet(wb, rangeWS, "Ranges");

        const adjHeader = ["(L/C)", ...chromaRanges.map(c => c.label)];
        const adjBody = adjectiveMatrix.map((row, i) => [lightRanges[i]?.label || `L${i}`, ...row]);
        const adjWS = XLSX.utils.aoa_to_sheet([adjHeader, ...adjBody]);
        XLSX.utils.book_append_sheet(wb, adjWS, "Adjectives"); 
        
        const nounHeader = ["Hue Angle", "Dark Shade (L<50)", "Light Shade (L≥50)"];
        const nounBody = nounData.map((row, i) => [`${hueValues[i]}°`, ...row.split(',')]);
        const nounWS = XLSX.utils.aoa_to_sheet([nounHeader, ...nounBody]);
        XLSX.utils.book_append_sheet(wb, nounWS, "Nouns"); 
        
        const sessionHeader = ["Key", "Value"];
        const sessionBody = [
            ["Current L", l],
            ["Current C", c],
            ["Current H", h],
            ["Active View", activeView],
            ["Flipped", isFlipped],
            ["Palette JSON", JSON.stringify(palette)]
        ];
        const sessionWS = XLSX.utils.aoa_to_sheet([sessionHeader, ...sessionBody]);
        XLSX.utils.book_append_sheet(wb, sessionWS, "Session");

        XLSX.writeFile(wb, "ColorSAMIficator_Manufacturing.xlsx"); 
    }; 

    const handleImport = (e) => { 
        const file = e.target.files[0]; if(!file) return; 
        const reader = new FileReader(); 
        reader.onload = (evt) => { 
            const wb = XLSX.read(evt.target.result, {type: 'binary'}); 
            
            if(wb.Sheets["Ranges"]) {
                const rangeRaw = XLSX.utils.sheet_to_json(wb.Sheets["Ranges"]);
                const newL = rangeRaw.filter(r => r.Type === "Light").map(r => ({ label: r.Label, min: parseInt(r.Min), max: parseInt(r.Max), mid: parseFloat(r.Mid) }));
                const newC = rangeRaw.filter(r => r.Type === "Chroma").map(r => ({ label: r.Label, min: parseInt(r.Min), max: parseInt(r.Max), mid: parseFloat(r.Mid) }));
                if (newL.length > 0) setLightRanges(newL);
                if (newC.length > 0) setChromaRanges(newC);
            }

            if(wb.Sheets["Adjectives"]) { 
                const rawAdj = XLSX.utils.sheet_to_json(wb.Sheets["Adjectives"], {header: 1}); 
                let matrixData = rawAdj;
                if (rawAdj.length > 0 && rawAdj[0][0] === "(L/C)") {
                     const body = rawAdj.slice(1);
                     matrixData = body.map(row => row.slice(1));
                }
                setAdjectiveMatrix(matrixData.map(row => row.map(cell => cell || "")));
            } 
            
            if(wb.Sheets["Nouns"]) { 
                const rawNouns = XLSX.utils.sheet_to_json(wb.Sheets["Nouns"], {header: 1}); 
                if (rawNouns.length > 0) {
                    const headerRow = rawNouns[0];
                    let startIndex = 0;
                    if (headerRow[0] === "Hue Angle") startIndex = 1;
                    const body = rawNouns.slice(1);
                    const newHues = [];
                    const newNouns = body.map(row => {
                        const hueStr = row[0].toString().replace('°','');
                        newHues.push(parseInt(hueStr));
                        const nounParts = row.slice(startIndex, startIndex + 2); // 2 columns
                        return nounParts.map(n => n || "Hue").join(',');
                    });
                    setHueValues(newHues);
                    setNounData(newNouns);
                }
            }

            if(wb.Sheets["Session"]) {
                const sessionRaw = XLSX.utils.sheet_to_json(wb.Sheets["Session"], {header: 1}); 
                sessionRaw.forEach(row => {
                    const k = row[0]; const v = row[1];
                    if (k === "Current L") setL(parseFloat(v));
                    if (k === "Current C") setC(parseFloat(v));
                    if (k === "Current H") setH(parseFloat(v));
                    if (k === "Active View") setActiveView(v);
                    if (k === "Flipped") setIsFlipped(v === "true" || v === true);
                    if (k === "Palette JSON") {
                        try { setPalette(JSON.parse(v)); } catch(e) {}
                    }
                });
            }
        }; 
        reader.readAsBinaryString(file); 
        e.target.value = "";
    }; 

    const generateSliderBackground = (mode) => { 
        const stops = []; const steps = 20; 
        for (let i = 0; i <= steps; i++) { 
            const pct = i / steps; let lV = l, cV = c, hV = h; 
            if (mode === 'light') lV = pct * 100; else if (mode === 'chroma') cV = pct * 100; else hV = hueValues[Math.min(hueValues.length-1, Math.round(pct * (hueValues.length-1)))]; 
            
            const gamutStatus = checkGamut(lV, cV, hV);
            const isOut = displayGamut === 'p3' ? !gamutStatus.isP3 : !gamutStatus.isSRGB;
            
            const color = isOut ? 'transparent' : `lch(${lV}% ${cV} ${hV})`; 
            stops.push(`${color} ${pct * 100}%`); 
        } 
        return `linear-gradient(to right, ${stops.join(', ')})`; 
    }; 

    const lightRangeData = useMemo(() => lightRanges.map((r, i) => ({ label: r.label, index: i, isActive: i === safeLIdx, data: r })), [safeLIdx, lightRanges]);
    const chromaRangeData = useMemo(() => chromaRanges.map((r, i) => ({ label: r.label, index: i, isActive: i === safeCIdx, data: r })), [safeCIdx, chromaRanges]);
    
    const hueRangesData = useMemo(() => hueValues.map((val, i) => {
        const nextVal = hueValues[i+1] !== undefined ? hueValues[i+1] : 360;
        const maxVal = nextVal - (nextVal > val ? 1 : 0);
        return { 
            label: `${val}°`, 
            index: i, 
            isActive: i === hIdx, 
            data: { min: val, max: maxVal > val ? maxVal : val }
        };
    }), [hIdx, hueValues]);

    const renderCell = useCallback((rI, cI) => {
        const { lVal, cVal, hVal, lIdx: cellL, cIdx: cellC, hIdx: cellH } = getExplorerParams(activeView, isFlipped, rI, cI);
        
        const gamutStatus = checkGamut(lVal, cVal, hVal);
        const isOut = displayGamut === 'p3' ? !gamutStatus.isP3 : !gamutStatus.isSRGB;

        const isActive = cellL === safeLIdx && cellC === safeCIdx && cellH === hIdx;
        
        const anchor = getNounColumnIndex(cellL);
        let noun = parsedNouns[cellH]?.[anchor] || "Hue";
        if (cellL === 0) noun = "Nero"; else if (cellL === 21) noun = "Blanc"; else if (cellC === 0) noun = "Cinza";

        // V111 Logic: Fix Nero/Blanc to only show in Column 0
        if ((cellL === 0 || cellL === 21) && cellC > 0) {
            return <td key={`${rI}-${cI}`} className="p-0 h-16 w-16 relative border-none bg-slate-50/50"></td>;
        }

        return (
            <td key={`${rI}-${cI}`} className="p-0 h-16 w-16 relative border-none" style={{zIndex: isActive ? 60 : 'auto'}}>
                <div onClick={() => { 
                    interactionSource.current = 'click';
                    setL(lVal); setC(cVal); setH(hVal); 
                }} 
                    className={`w-full h-full rounded-md overflow-hidden transition-all duration-300 ease-[cubic-bezier(0.34,1.56,0.64,1)] border border-slate-100 ${isActive ? 'scale-110 shadow-xl ring-2 ring-blue-500' : 'hover:scale-105 hover:shadow-md'}`} 
                    style={{ backgroundColor: isOut ? 'transparent' : `lch(${lVal}% ${cVal} ${hVal})`, backgroundImage: isOut ? 'repeating-linear-gradient(45deg, #cbd5e1 0px, #cbd5e1 4px, transparent 4px, transparent 8px)' : 'none', color: lVal > 55 ? 'black' : 'white' }}
                    data-active={isActive}>
                    <div className="flex flex-col h-full justify-center px-1 text-center">
                        <div className="text-[9px] font-bold opacity-70 leading-none mb-0.5">{adjectiveMatrix[cellL]?.[cellC] || ""}</div>
                        <div className="text-[8px] leading-none opacity-90">{noun}</div>
                    </div>
                </div>
            </td>
        );
    }, [activeView, isFlipped, getExplorerParams, safeLIdx, safeCIdx, hIdx, parsedNouns, lightRanges.length, adjectiveMatrix, displayGamut]);

    const isCanonOut = displayGamut === 'p3' ? !canonGamut.isP3 : !canonGamut.isSRGB;
    const swatchStyle = isCanonOut ? { backgroundImage: 'repeating-linear-gradient(45deg, #cbd5e1 0px, #cbd5e1 4px, transparent 4px, transparent 8px)', backgroundColor: 'transparent' } : { backgroundColor: `rgb(${canonRgb.r},${canonRgb.g},${canonRgb.b})` };

    return ( 
    <div className="w-full h-full bg-white md:rounded-3xl shadow-xl border border-slate-100 flex flex-col overflow-hidden"> 
    <div className="shrink-0 py-2 md:py-4 flex flex-col items-center bg-white z-20 shadow-sm relative"> 
        <h1 className="text-xl md:text-3xl font-black tracking-tighter text-slate-900">The COLOR<span className="text-green-700">SAMI</span>FICATOR</h1> 
        <div className="flex items-center gap-2 mt-1">
            <span className={`text-[10px] font-bold uppercase tracking-widest px-2 py-0.5 rounded ${displayGamut === 'p3' ? 'bg-purple-100 text-purple-700' : 'bg-slate-100 text-slate-500'}`}>
                {displayGamut === 'p3' ? 'Display P3' : 'sRGB'}
            </span>
            <div className={`px-2 py-0.5 rounded-full flex items-center gap-1 transition-colors ${!isCloudEnabled ? 'bg-slate-100 text-slate-400' : hasUnsavedChanges ? 'bg-amber-100 text-amber-700' : 'bg-blue-100 text-blue-700'}`}>
                <div className={`w-1.5 h-1.5 rounded-full ${!isCloudEnabled ? 'bg-slate-400' : hasUnsavedChanges ? 'bg-amber-500' : 'bg-blue-500'}`}></div>
                <span className="text-[9px] font-black uppercase tracking-wide">{!isCloudEnabled ? "OFFLINE" : hasUnsavedChanges ? "UNSAVED" : "LIVE"}</span>
            </div>
        </div>
        <div className="absolute right-2 md:right-6 top-1/2 -translate-y-1/2 flex gap-1 md:gap-2"> 
            <button 
                onClick={handleCloudSave} 
                disabled={!isCloudEnabled}
                className={`p-2 rounded-full transition-colors ${isCloudEnabled ? 'hover:bg-blue-50 text-blue-600' : 'opacity-30 cursor-not-allowed text-slate-400'}`} 
                title={isCloudEnabled ? "Save to Cloud" : "Cloud Unavailable"}
            >
                {isCloudEnabled ? <Cloud className="w-5 h-5" /> : <CloudOff className="w-5 h-5" />}
            </button>
            <Download onClick={handleExport} className="w-9 h-9 p-2 rounded-full hover:bg-slate-100 text-slate-600 cursor-pointer" />
            <label className="p-2 rounded-full hover:bg-slate-100 text-slate-600 cursor-pointer"><Upload className="w-5 h-5" /><input type="file" onChange={handleImport} className="hidden" accept=".xlsx, .xls" /></label> 
        </div> 
    </div> 
    
    <div className="flex-1 min-h-0 flex flex-col md:flex-row"> 
        <div className="order-1 w-full md:w-[420px] shrink-0 flex-none md:flex-1 h-[45%] md:h-full border-b md:border-b-0 md:border-r border-slate-100 flex flex-col p-4 md:p-6 bg-white z-10 overflow-y-auto"> 
        
        {/* SWATCH CONTAINER - Restored Visibility & Style */}
        <div className="w-full aspect-[3/1] md:aspect-[2/1] rounded-xl md:rounded-3xl flex flex-col items-center justify-center relative overflow-hidden mb-4 transition-all duration-300 min-h-[160px] border border-slate-200 shadow-sm" style={swatchStyle}> 
            <div className="z-20 text-center flex flex-col items-center w-full px-6"> 
                <div className="bg-white/90 backdrop-blur text-slate-900 px-3 py-1 rounded-full text-xs font-mono font-bold mb-2 md:mb-4 shadow-sm border border-white/50 flex items-center gap-1 z-10"><Tag className="w-3 h-3 text-blue-500" /> {currentMapping.code}</div> 
                
                <input 
                    type="text" 
                    value={tempName !== null ? tempName : fullDisplayName} 
                    onChange={(e) => {
                        setTempName(e.target.value);
                        handleNameChange(e.target.value);
                    }}
                    onBlur={() => setTempName(null)}
                    className="font-black text-xl md:text-3xl w-full text-center leading-tight break-words bg-transparent border-none outline-none text-shadow-sm hover:bg-white/10 rounded transition-colors z-10 relative" 
                    style={{ color: canonicalL > 50 ? 'black' : 'white', textShadow: canonicalL > 50 ? 'none' : '0 2px 10px rgba(0,0,0,0.2)' }} 
                />

                {nameWarning && (
                    <div className="mt-2 px-3 py-1 bg-red-500/90 backdrop-blur text-white text-[10px] font-bold rounded-full flex items-center gap-1 shadow-lg animate-bounce z-10">
                        <AlertTriangle className="w-3 h-3" />
                        {nameWarning}
                    </div>
                )}

                <div className="mt-2 md:mt-4 flex gap-2 flex-wrap justify-center z-10"> 
                    <div className="px-2 py-1 bg-black/40 backdrop-blur-md rounded text-[10px] font-mono text-white flex items-center gap-1">L{Math.round(canonicalL)} C{Math.round(canonicalC)} H{Math.round(canonicalH)}</div> 
                    <div className="px-2 py-1 bg-black/40 backdrop-blur-md rounded text-[10px] font-mono text-white flex items-center gap-1"><Hash className="w-3 h-3 opacity-70" /> {canonHex}</div> 
                    <div className="px-2 py-1 bg-black/40 backdrop-blur-md rounded text-[10px] font-mono text-white flex items-center gap-1">RGB {canonRgb.r},{canonRgb.g},{canonRgb.b}</div> 
                    <div className="px-2 py-1 bg-white text-blue-600 backdrop-blur-md rounded text-[10px] font-black flex items-center gap-1"><Ruler className="w-3 h-3" /> ΔE {deltaE}</div> 
                </div> 
            </div> 
        </div> 

        <div className="bg-slate-50 p-4 md:p-6 rounded-2xl border border-slate-100 space-y-2 shrink-0"> 
            <SnapControl label="Light" value={l} setter={setL} max={100} displayVal={Math.round(l)} gradient={generateSliderBackground('light')} isActive={activeView.includes('hue') || activeView.includes('chroma')} /> 
            <SnapControl label="Chroma" value={c} setter={setC} max={100} displayVal={Math.round(c)} gradient={generateSliderBackground('chroma')} isActive={activeView.includes('hue') || activeView.includes('light')} /> 
            <SnapControl label="Hue" value={h} setter={setH} max={360} displayVal={Math.round(h) + "°"} gradient={generateSliderBackground('hue')} isActive={activeView.includes('chroma') || activeView.includes('light')} /> 
        </div> 

        <div className="bg-slate-50 p-4 rounded-2xl border border-slate-100 shrink-0 my-4"> 
            <div className="text-[10px] font-bold text-slate-400 uppercase mb-3 flex items-center gap-2"><Palette className="w-3 h-3" /> Harmonies</div> 
            <div className="flex justify-between items-center px-2 overflow-x-auto scroll-hide pb-2"> 
                <HarmonySwatch offset={0} label="Base" currentH={h} currentL={l} currentC={c} setH={setH} displayGamut={displayGamut} /> 
                <div className="w-px h-6 bg-slate-200 mx-2 flex-shrink-0"></div> 
                <HarmonySwatch offset={180} label="Comp" currentH={h} currentL={l} currentC={c} setH={setH} displayGamut={displayGamut} /> 
                <HarmonySwatch offset={-30} label="Ana -" currentH={h} currentL={l} currentC={c} setH={setH} displayGamut={displayGamut} /> 
                <HarmonySwatch offset={30} label="Ana +" currentH={h} currentL={l} currentC={c} setH={setH} displayGamut={displayGamut} /> 
                <div className="w-px h-6 bg-slate-200 mx-2 flex-shrink-0"></div> 
                <HarmonySwatch offset={120} label="Tri 1" currentH={h} currentL={l} currentC={c} setH={setH} displayGamut={displayGamut} /> 
                <HarmonySwatch offset={240} label="Tri 2" currentH={h} currentL={l} currentC={c} setH={setH} displayGamut={displayGamut} /> 
            </div> 
        </div>

        {/* PALETTE PLAYGROUND */}
        <div className="bg-slate-50 p-4 rounded-2xl border border-slate-100 shrink-0 mb-4">
            <div className="flex justify-between items-center mb-3">
                <div className="text-[10px] font-bold text-slate-400 uppercase flex items-center gap-2"><Layers className="w-3 h-3" /> Palette Playground</div>
                <div className="text-[9px] font-bold text-slate-300 uppercase">{palette.length}/10</div>
            </div>
            <div className="flex flex-wrap gap-2">
                {palette.map((p, i) => {
                     const gamutStatus = checkGamut(p.l, p.c, p.h);
                     const isOut = displayGamut === 'p3' ? !gamutStatus.isP3 : !gamutStatus.isSRGB;
                     const rgbVal = realLchToRgb(p.l, p.c, p.h);
                     
                     const pBg = `rgb(${rgbVal.r},${rgbVal.g},${rgbVal.b})`;
                     const style = isOut ? { backgroundImage: 'repeating-linear-gradient(45deg, #cbd5e1 0px, #cbd5e1 2px, transparent 2px, transparent 6px)', backgroundColor: 'transparent' } : { backgroundColor: pBg };
                     return (
                         <div key={i} onClick={() => { setL(p.l); setC(p.c); setH(p.h); }} className="w-8 h-8 rounded-lg shadow-sm border border-black/10 cursor-pointer relative group transition-transform hover:scale-110" style={style}>
                            <div onClick={(e) => { e.stopPropagation(); setPalette(palette.filter((_, idx) => idx !== i)); }} className="absolute -top-1 -right-1 bg-white text-slate-400 hover:text-red-500 rounded-full p-0.5 shadow-md opacity-0 group-hover:opacity-100 transition-opacity">
                                <X className="w-2 h-2" />
                            </div>
                         </div>
                     );
                })}
                {palette.length < 10 && (
                    <button onClick={() => setPalette([...palette, {l, c, h}])} className="w-8 h-8 rounded-lg border-2 border-dashed border-slate-200 flex items-center justify-center text-slate-300 hover:border-slate-300 hover:text-slate-400 transition-colors">
                        <Plus className="w-4 h-4" />
                    </button>
                )}
            </div>
        </div>

        <div className="mt-2 p-4 bg-blue-50 border border-blue-100 rounded-xl text-[10px] text-blue-600 hidden md:block">
            <h4 className="font-bold uppercase mb-1 flex items-center gap-1"><Monitor className="w-3 h-3" /> Monitor Profile: {displayGamut.toUpperCase()}</h4>
            <p>Gamut warnings and colors are optimized for your screen capabilities.</p>
        </div>
        </div> 
        
        <div className="order-2 flex-1 flex flex-col min-w-0 h-[55%] md:h-full bg-slate-50/50"> 
        <div className="h-14 border-b border-slate-200 flex items-center px-4 md:px-6 justify-between bg-white shrink-0"> 
            <div className="flex items-center gap-2"><Grid className="w-4 h-4 text-blue-500" /><span className="text-xs font-bold uppercase tracking-wider text-slate-500">Explorer Grid</span></div> 
            <div className="flex items-center gap-2"> 
                <RefreshCw onClick={() => setIsFlipped(!isFlipped)} className={`p-2 w-8 h-8 rounded hover:bg-slate-100 text-slate-500 cursor-pointer ${isFlipped ? 'text-blue-600' : ''}`} /> 
                <select value={activeView} onChange={(e) => setActiveView(e.target.value)} className="bg-slate-100 pl-4 pr-8 py-1.5 rounded-lg text-xs font-bold text-slate-700 cursor-pointer appearance-none"> 
                    <option value="hue_pivot">HUE FIXED</option> 
                    <option value="chroma_pivot">CHROMA FIXED</option> 
                    <option value="light_pivot">LIGHT FIXED</option> 
                    <option value="noun">NOUN LIST</option> 
                </select> 
            </div> 
        </div> 
        <div className="flex-1 overflow-hidden relative p-2 md:p-4"> 
            {activeView === 'hue_pivot' && ( 
            <MatrixTable yLabel={isFlipped ? "C" : "L"} xLabel={isFlipped ? "L" : "C"} yData={isFlipped ? chromaRangeData : lightRangeData} xData={isFlipped ? lightRangeData : chromaRangeData} activeIds={{r: isFlipped ? safeCIdx : safeLIdx, c: isFlipped ? safeLIdx : safeCIdx}} renderCell={renderCell} interactionSource={interactionSource} /> 
            )} 
            {activeView === 'chroma_pivot' && ( 
            <MatrixTable yLabel={isFlipped ? "L" : "H"} xLabel={isFlipped ? "H" : "L"} yData={isFlipped ? lightRangeData : hueRangesData} xData={isFlipped ? hueRangesData : lightRangeData} activeIds={{r: isFlipped ? safeLIdx : hIdx, c: isFlipped ? hIdx : safeLIdx}} renderCell={renderCell} interactionSource={interactionSource} /> 
            )} 
            {activeView === 'light_pivot' && ( 
            <MatrixTable yLabel={isFlipped ? "C" : "H"} xLabel={isFlipped ? "H" : "C"} yData={isFlipped ? chromaRangeData : hueRangesData} xData={isFlipped ? hueRangesData : chromaRangeData} activeIds={{r: isFlipped ? safeCIdx : hIdx, c: isFlipped ? hIdx : safeCIdx}} renderCell={renderCell} interactionSource={interactionSource} /> 
            )} 
            {activeView === 'noun' && ( 
             <div className="h-full w-full overflow-auto rounded-xl border border-slate-200 bg-white shadow-sm"> 
                 <table className="w-full text-xs text-left table-fixed border-separate border-spacing-0"> 
                 <thead className="bg-white sticky top-0 z-20 shadow-sm border-b border-slate-200"> 
                     <tr> 
                     <th className="p-3 font-bold text-slate-400 w-16 text-center bg-white sticky left-0 z-30 border-b border-slate-200">Hue</th> 
                     <th className="p-3 font-bold text-slate-600 bg-slate-50 border-b border-r border-slate-200">Dark Shade (L&lt;50)</th>
                     <th className="p-3 font-bold text-slate-600 bg-slate-50 border-b border-slate-200">Light Shade (L&ge;50)</th>
                     </tr> 
                 </thead> 
                 <tbody> 
                 {nounData.map((rowStr, idx) => { 
                     const displayHue = hueValues[idx]; 
                     const parts = rowStr.split(','); 
                     const isHueActive = hIdx === idx;
                     // Column 0 = Dark, Column 1 = Light
                     return ( 
                     <tr key={idx} className={`transition-all duration-200 cursor-pointer ${isHueActive ? 'bg-blue-50/50' : 'hover:bg-slate-50'}`} data-active={isHueActive}> 
                         <td onClick={() => setH(displayHue)} className={`p-2 text-center font-mono opacity-80 bg-white sticky left-0 z-10 border-b border-r border-slate-100 ${isHueActive ? '!bg-blue-50 font-bold text-blue-600' : ''}`}>{displayHue}°</td> 
                         {[0, 1].map((colIdx) => {
                             const n = parts[colIdx] || "";
                             const isCellActive = isHueActive && (colIdx === (l < 50 ? 0 : 1));
                             // Set representative L/C for clicking the list
                             const repL = colIdx === 0 ? 25 : 75;
                             const repC = 30; // Generic chroma
                             const cellRgb = realLchToRgb(repL, repC, displayHue);
                             const cellColor = `rgb(${cellRgb.r},${cellRgb.g},${cellRgb.b})`;
                             
                             return (
                                 <td key={colIdx} onClick={() => { setH(displayHue); setL(repL); setC(repC); }} className={`p-0 relative h-10 border-b border-r border-slate-100 ${isCellActive ? 'ring-2 ring-blue-500 z-20' : ''}`}>
                                    <div className="flex items-center h-full px-3 gap-2">
                                        <div className="w-4 h-4 rounded-full border border-black/10" style={{backgroundColor: cellRgb.outOfGamut ? 'transparent' : cellColor, backgroundImage: cellRgb.outOfGamut ? 'repeating-linear-gradient(45deg, #cbd5e1 0px, #cbd5e1 4px, transparent 4px, transparent 8px)' : 'none'}}></div>
                                        <input type="text" value={n} onChange={(e) => updateNoun(idx, colIdx, e.target.value)} className="w-full bg-transparent border-none outline-none font-medium text-slate-700" />
                                    </div>
                                 </td>
                             )
                         })}
                     </tr> 
                     ); 
                 })} 
                 </tbody> 
                 </table> 
             </div> 
            )} 
        </div> 
        </div> 
    </div> 
    </div> 
    ); 
 }; 
 const root = ReactDOM.createRoot(document.getElementById('root')); 
 root.render(<ColorSAMIfier />); 
 </script> 
</body> 
</html>